#version 430

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

layout(location=0) uniform float time;
layout(location=1) uniform int depthLevel;
layout(location=2) uniform int workGroupWidth;
layout(location=3) uniform vec4 ambientColour;

struct RayHit
{
	vec4 hitAndWeight;
	vec4 normal;
	vec4 viewDir;
	ivec4 pixelCoordsObjIdType;
};

layout (std140) buffer rHitBuffer
{
	RayHit hits[];
};

struct Spheres
{
	vec4 posAndScale;
	vec4 diffColAlpha;
	vec4 specDiffAmbiCoefShinness;
	vec4 refrIndexReflCoef; //And two padding
};

layout (std140) buffer sBuffer
{
	Spheres spheres[];
};

//define light
vec3 lightPos = vec3(0.0, 0.0, 0.0);
vec4 lightColor = vec4(1.0, 1.0, 1.0, 1.0);

//===========AUXILIAR=FUNCTIONS===========//
//These are implemented in hardware, that's why they use vec4s
//Could stack 4 values at a time for comparisong

vec4 shade(vec3 point, vec3 normal, vec3 viewDir, int objId) {

		//ambient
		float ka = spheres[objId].specDiffAmbiCoefShinness.z;  //coeficient of ambient light
		vec4 ia = ambientColour * ka;

		//diffuse
		float kd = spheres[objId].specDiffAmbiCoefShinness.y; // coeficient of diffuse light
		vec4 diffuseColor = vec4(spheres[objId].diffColAlpha.rgb, 1); // color from the object

		vec3 lightDir = normalize(lightPos - point);
		float diffuse = clamp(dot(lightDir, normal), 0, 1);
		vec4 id = kd * diffuse * diffuseColor * lightColor;

		//specular TODO: review this
		float ks = spheres[objId].specDiffAmbiCoefShinness.x;
		float specullarPower = spheres[objId].specDiffAmbiCoefShinness.w;

		//Reflect = lightDir - 2 * normal * dot(normal, lightDir)
		//Ou normalize(2 * normal * dot(normal, lightDir) - lightDir) quando o raio vem da fonte de luz
		vec3 reflect = normalize(lightDir - 2 * normal * diffuse);
		float specular = clamp(abs(pow(dot(reflect, viewDir), specullarPower)), 0, 1);
		
		vec4 is = ks * specular * lightColor;

		return (ia + id + is);
}

void main() {
	// base pixel colour for image
	vec4 pixel = const vec4(0.0f, 0.4509803921568627f, 0.8980392156862745f, 1.0);

	// get index in global work group i.e x,y position
	const ivec2 global_coords = ivec2(gl_GlobalInvocationID.xy);

	//Get working ray id
	const int hitId = global_coords.x + global_coords.y * workGroupWidth;

	//Get texture pixel coords from hit
	const ivec2 pixelCoords = hits[hitId].pixelCoordsObjIdType.xy;

	//Get object id from hit
	const int objId = hits[hitId].pixelCoordsObjIdType.z;

	if (objId != -1) //TODO: OPTIMIZE THIS!
	{
		vec3 hitPos = hits[hitId].hitAndWeight.xyz;
		vec3 hitNor = hits[hitId].normal.xyz;
		vec3 viewDir = hits[hitId].viewDir.xyz;
		
		//Do proper shading
		pixel = shade(hitPos, hitNor, viewDir, objId);

		//create rays
	}

	//Get last pass pixel (only if this is not the first pass)
	vec4 lastPixel = imageLoad(img_output, pixelCoords) * (1 - step(depthLevel, 0));

	//Calculate final pass pixel
	vec4 outPixel = lastPixel + pixel * hits[hitId].hitAndWeight.w;

	imageStore(img_output, pixelCoords, outPixel);
}
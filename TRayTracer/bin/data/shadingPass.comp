#version 430

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

uniform float time;
uniform int depthLevel;
uniform int workGroupWidth;
uniform vec4 ambientColour;

struct RayHit
{
	vec4 hitAndWeight;
	vec4 normal;
	vec4 viewDir;
	ivec4 pixelCoordsObjIdType;
};

layout (std140) buffer rHitBuffer
{
	RayHit hits[];
};

struct Spheres
{
	vec4 posAndScale;
	vec4 diffColAlpha;
	vec4 specDiffAmbiCoefShinness;
	vec4 refrIndexReflCoef; //And two padding
};

layout (std140) buffer sBuffer
{
	Spheres spheres[];
};

//define light
vec3 lightPos = vec3(0.0, 0.0, 0.0);
vec4 lightColor = vec4(1.0, 1.0, 1.0, 1.0);

//Returns 0 when equal and 1 when not
vec4 when_neq(vec4 x, vec4 y) {
  return abs(sign(x - y));
}

vec4 shade(vec3 point, vec3 normal, vec3 viewDir, int objId) {

		//ambient
		float ka = spheres[objId].specDiffAmbiCoefShinness.z;  //coeficient of ambient light
		vec4 ia = ambientColour * ka;

		//diffuse
		float kd = spheres[objId].specDiffAmbiCoefShinness.y; // coeficient of diffuse light
		vec4 diffuseColor = vec4(spheres[objId].diffColAlpha.rgb, 1); // color from the object

		vec3 lightDir = normalize(lightPos - point);
		float diffuse = clamp(dot(lightDir, normal), 0, 1);
		vec4 id = kd * diffuse * diffuseColor * lightColor;

		//specular TODO:review this
		float ks = spheres[objId].specDiffAmbiCoefShinness.x;
		float specullarPower = spheres[objId].specDiffAmbiCoefShinness.w;

		//Reflect = lightDir - 2 * normal * dot(normal, lightDir)
		//Ou normalize(2 * normal * dot(normal, lightDir) - lightDir) quando o raio vem da fonte de luz
		vec3 reflect = normalize(lightDir - 2 * normal * diffuse);
		float specular = clamp(abs(pow(dot(reflect, viewDir), specullarPower)), 0, 1);
		
		vec4 is = ks * specular * lightColor;

		return (ia + id + is);
}

void main() {
	// base pixel colour for image
	vec4 pixel = vec4(0.0f, 0.4509803921568627f, 0.8980392156862745f, 1.0);

	// get index in global work group i.e x,y position
	ivec2 global_coords = ivec2(gl_GlobalInvocationID.xy);

	//Get working ray id
	int hitId = global_coords.x + global_coords.y * workGroupWidth;

	//Get texture pixel coords from hit
	ivec2 pixelCoords = hits[hitId].pixelCoordsObjIdType.xy;

	//Get object id from hit
	int objId = hits[hitId].pixelCoordsObjIdType.z;

	if(objId != -1)
	{
		vec3 hitPos = hits[hitId].hitAndWeight.xyz;
		vec3 hitNor = hits[hitId].normal.xyz;
		vec3 viewDir = hits[hitId].viewDir.xyz;
		
		//Do proper shading
		pixel = shade(hitPos, hitNor, viewDir, objId);
	}

	//Calculate final pass pixel
	vec4 outPixel = imageLoad(img_output, pixelCoords) * when_neq(vec4(depthLevel), vec4(0)) + pixel * hits[hitId].hitAndWeight.w;

	imageStore(img_output, pixelCoords, outPixel);
}
#version 430

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(location=0) uniform float time;
layout(location=1) uniform int spheresCount;
layout(location=2) uniform int workGroupWidth;
layout(location=3) uniform int workGroupHeight;
layout(location=4) uniform int depthLevel;

struct Ray
{
	vec4 origAndWght;
	vec4 dir;
	ivec4 pixelCoords; //And two padding
};

layout (std140) buffer rBuffer
{
  Ray rays[];
};

struct RayHit
{
	vec4 hitAndWeight;
	vec4 normal;
	vec4 rayDir;
	ivec4 pixelCoordsObjIdType;
};

layout (std140) buffer rHitBuffer
{
	RayHit hits[];
};

struct Spheres
{
	vec4 posAndScale;
};

layout (std140) buffer sBuffer
{
	Spheres spheres[];
};

layout (std140) buffer vBuffer
{
	vec4 vertices[];
};

layout (std140) buffer nBuffer
{
	vec4 normals[];
};

struct Triangle
{
	ivec4 vId;
	ivec4 nId;
};

layout (std140) buffer tBuffer
{
	Triangle triangles[];
};

//===========AUXILIAR=FUNCTIONS===========//
//These are implemented in hardware, that's why they use vec4s
//Could stack 4 values at a time for comparisong

//Returns 1 when x equals y and 0 when not
vec4 when_eq(vec4 x, vec4 y) {
  return 1.0 - abs(sign(x - y));
}

//Returns 0 when x equals y and 1 when not
vec4 when_neq(vec4 x, vec4 y) {
  return abs(sign(x - y));
}

//Returns 1 when x is greater then y and 0 when equal or smaller
vec4 when_gt(vec4 x, vec4 y) {
  return max(sign(x - y), 0.0);
}

//Returns 0 when x is greater or equal then y and 1 when smaller
vec4 when_le(vec4 x, vec4 y) {
  return 1.0 - when_gt(x, y);
}


void main()
{
	//Get working ray id
	const int rayId = int(gl_GlobalInvocationID.x);

	//Get working triangle id
	const int triangleId = int(gl_GlobalInvocationID.y);

	//Create ray's if first depth pass
	if(depthLevel == 0)
	{
		const vec2 screenSize = vec2(workGroupWidth, workGroupHeight);
		const float aspectRatio = screenSize.x / screenSize.y;
		const float fov = 33.0; //get this from options
		const float fovScale = tan(radians(fov * 0.5));
		const ivec2 screen_coord = ivec2(mod(rayId, workGroupWidth), rayId/workGroupWidth);
		const vec4 origin = { 0, 0, 20, 1 };

		const float x = (2.0 * (screen_coord.x + 0.5) / screenSize.x - 1.0) * aspectRatio * fovScale;
		const float y = (1.0 - 2.0 * (screen_coord.y + 0.5) / screenSize.y) * fovScale;
		vec3 dir = vec3( x, y, -1.0f );
		dir = normalize(dir);

		//Create ray in memory
		rays[rayId].origAndWght = origin;
		rays[rayId].dir = vec4(dir, 0);
		rays[rayId].pixelCoords = screen_coord.xyxy;

	}

	//Get triangle vertices
	vec3 v1 = vertices[triangles[triangleId].vId[0]].xyz; //First Vertex
	vec3 v2 = vertices[triangles[triangleId].vId[1]].xyz; //Second Vertex
	vec3 v3 = vertices[triangles[triangleId].vId[2]].xyz; //Third Vertex

	//Get triangle side vectors
	vec3 tu = v2-v1;	//Triangle U component
	vec3 tv = v3-v1;	//Triangle V component

	//Get ray info
	ivec2 pixelCoords = rays[rayId].pixelCoords.xy;
	vec3 rayOrigin = rays[rayId].origAndWght.xyz;
	vec3 rayDir = rays[rayId].dir.xyz;

	//=====Solve for collision=====//
	//Triangle origin to ray origin vector
	vec3 tr = rayOrigin - v1;

	//Determinant for inverse matrix
	float invdet = 1.0/abs(dot(tu, cross(tv, rayDir)));

	//Solve component parameters
	float u = dot(cross(tv, rayDir) * invdet, tr);
	float v = dot(cross(rayDir, tu) * invdet, tr);
	float t = -dot(cross(tu, tv) * invdet, tr);

	//Use 'u' and 'v' to check for triangle boundaries
	if (u > 0 && v > 0 && (u+v) <= 1 && t >= 0)
	{
		//TODO: Check for closest hit
		vec3 hit = rayOrigin + rayDir * t;

		//TODO: Interpolate normals
		//Get triangle vertices
		vec3 n1 = normals[triangles[triangleId].nId[0]].xyz; //First Vertex
		vec3 n2 = normals[triangles[triangleId].nId[1]].xyz; //Second Vertex
		vec3 n3 = normals[triangles[triangleId].nId[2]].xyz; //Third Vertex
		vec3 normal = n1 * (1.0f-(u+v)) + n2 * u + n3 * v;
		normal = vec3(0, 0, 1);
		normal = normalize(normal);

		if(hits[rayId].rayDir.w > t || depthLevel == 0)
		{
			hits[rayId] = RayHit(vec4(hit, rays[rayId].origAndWght.w), vec4(normal, 0), vec4(rayDir, t), ivec4(pixelCoords.xy, triangleId, 1));
		}
	}
}
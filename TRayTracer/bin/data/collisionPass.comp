#version 430

layout(local_size_x = 1, local_size_y = 1) in;

uniform float time;
uniform int spheresCount;
uniform int workGroupWidth;

struct Ray
{
	vec4 origAndWght;
	vec4 dir;
	ivec4 pixelCoords; //And two padding
};

layout (std140) buffer rBuffer
{
  Ray rays[];
};

struct RayHit
{
	vec4 hitAndWeight;
	vec4 normal;
	vec4 viewDir;
	ivec4 pixelCoordsObjIdType;
};

layout (std140) buffer rHitBuffer
{
	RayHit hits[];
};

struct Spheres
{
	vec4 posAndScale;
	vec4 diffColAlpha;
	vec4 specDiffAmbiCoefShinness;
	vec4 refrIndexReflCoef;
};

layout (std140) buffer sBuffer
{
	Spheres spheres[];
};

void main()
{
	// base pixel colour for image
	vec4 pixel = vec4(0.0f, 0.4509803921568627f, 0.8980392156862745f, 1.0f);

	// get index in global work group i.e x,y position
	ivec2 global_coords = ivec2(gl_GlobalInvocationID.xy);

	//Get working ray id
	int rayId = global_coords.x + global_coords.y * workGroupWidth;
	ivec2 pixelCoords = rays[rayId].pixelCoords.xy;

	//define camera points
	vec3 cameraOrigin = rays[rayId].origAndWght.xyz;
	vec3 cameraDir = rays[rayId].dir.xyz; // ortho

	int indexClosestSphere = -1;
	float closestDelta = 4294967296.0;

	for(int i = 0; i < spheresCount; i++)
	{
		//define sphere
		vec3 sphereCenter = spheres[i].posAndScale.xyz;
		//vec3 sphereCenter = vec3(i * 5 - 15, sin(time + i*0.5f) * 3, -10.0);
		float sphereRadius = spheres[i].posAndScale.w;
		//float sphereRadius = 1;

		//region collision with sphere
		vec3 omc = cameraOrigin - sphereCenter; 
		float b = dot(cameraDir, omc);
		float c = dot(omc, omc) - sphereRadius * sphereRadius;
		float delta = b * b - c;

		// hit one or both sides
		if (delta >= 0.0) {
			float hitT = -b - delta;
			if(hitT < closestDelta && hitT > 1) {
				indexClosestSphere = i;
				closestDelta = hitT;
			}
		}
	}

	if(indexClosestSphere != -1)
	{
		vec3 sphereCenter = spheres[indexClosestSphere].posAndScale.xyz;
		//vec3 sphereCenter = vec3(indexClosestSphere * 5 - 15, sin(time + indexClosestSphere*0.5f) * 3, -10.0);
		float sphereRadius = spheres[indexClosestSphere].posAndScale.w;

		vec3 hit = vec3(cameraOrigin.x + cameraDir.x * closestDelta, cameraOrigin.y + cameraDir.y * closestDelta, cameraOrigin.z + cameraDir.z * closestDelta);
		vec3 normal = vec3((hit.x - sphereCenter.x)/sphereRadius,  (hit.y - sphereCenter.y)/sphereRadius, (hit.z - sphereCenter.z)/sphereRadius); 
		normal = normalize(normal);

		//Values to define
		vec4 hitAndWeight;
		vec4 norAndId;
		int objId;
		int objTypeId;

		hits[rayId].hitAndWeight = vec4(hit, rays[rayId].origAndWght.w);
		hits[rayId].normal = vec4(normal, 0);
		hits[rayId].viewDir = vec4(cameraDir, 0);
		hits[rayId].pixelCoordsObjIdType = ivec4(pixelCoords.xy, indexClosestSphere, 1);
	}
	else
	{
		hits[rayId].hitAndWeight = vec4(vec3(0), rays[rayId].origAndWght.w);
		hits[rayId].pixelCoordsObjIdType = ivec4(pixelCoords.xy, indexClosestSphere, 0);
	}
}